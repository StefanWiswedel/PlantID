<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flora Sjælland — Image Curator</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#f0f0f0;color:#222;font-size:14px}

/* Layout */
.top-bar{background:#fff;border-bottom:1px solid #ddd;padding:10px 16px;display:flex;align-items:center;justify-content:space-between;position:sticky;top:0;z-index:100}
.top-bar h1{font-size:16px;font-weight:600}
.progress{font-size:13px;color:#555}
.progress strong{color:#2d5a27}
.main{display:flex;height:calc(100vh - 45px)}
.sidebar{width:260px;min-width:260px;background:#fff;border-right:1px solid #ddd;overflow-y:auto;flex-shrink:0}
.content{flex:1;overflow-y:auto;padding:16px}

/* Sidebar */
.sp-item{display:flex;align-items:center;gap:8px;padding:9px 14px;cursor:pointer;border-bottom:1px solid #f0f0f0;font-size:13px;transition:background .1s}
.sp-item:hover{background:#f5f5f5}
.sp-item.active{background:#e8f0e6;font-weight:600}
.sp-tick{width:18px;height:18px;border-radius:50%;border:2px solid #ccc;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:11px;color:#fff}
.sp-tick.done{background:#2d5a27;border-color:#2d5a27}
.sp-info{min-width:0}
.sp-en{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.sp-la{font-size:11px;color:#888;font-style:italic;font-weight:normal}

/* Toolbar */
.toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;align-items:center}
.toolbar button{padding:6px 14px;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer;font-size:13px;font-weight:500;transition:all .15s}
.toolbar button:hover:not(:disabled){background:#eee}
.toolbar button:disabled{opacity:.5;cursor:default}
.toolbar .primary{background:#2d5a27;color:#fff;border-color:#2d5a27}
.toolbar .primary:hover:not(:disabled){background:#1e4a1a}
.toolbar .danger{color:#c33}

/* Status */
.status{padding:40px;text-align:center;color:#888;font-size:15px}

/* Loading */
.loading{text-align:center;padding:40px;color:#666}
.loading::after{content:'';display:block;width:28px;height:28px;border:3px solid #ddd;border-top-color:#2d5a27;border-radius:50%;animation:spin .6s linear infinite;margin:12px auto 0}
@keyframes spin{to{transform:rotate(360deg)}}

/* Image grid (available) */
.cat-section{margin-bottom:20px}
.cat-label{font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:.05em;color:#666;margin-bottom:8px;padding:4px 0;border-bottom:1px solid #e0e0e0}
.img-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:8px}
.thumb{position:relative;aspect-ratio:1;border-radius:6px;overflow:hidden;cursor:pointer;border:3px solid transparent;transition:border-color .15s,transform .1s;background:#e0e0e0}
.thumb:hover{transform:scale(1.02)}
.thumb.selected{border-color:#2d5a27}
.thumb img{width:100%;height:100%;object-fit:cover;display:block}
.thumb-badge{position:absolute;top:6px;left:6px;width:24px;height:24px;border-radius:50%;background:#2d5a27;color:#fff;font-size:12px;font-weight:700;display:none;align-items:center;justify-content:center}
.thumb.selected .thumb-badge{display:flex}
.thumb-src{position:absolute;bottom:0;left:0;right:0;background:rgba(0,0,0,.6);color:#fff;font-size:10px;padding:3px 6px;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.thumb-err{width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#aaa;font-size:11px;padding:8px;text-align:center}

/* Selected panel */
.sel-panel{margin-top:20px;background:#fff;border-radius:8px;border:1px solid #ddd;padding:16px}
.sel-panel h3{font-size:14px;margin-bottom:10px;font-weight:600}
.sel-empty{color:#999;font-size:13px;padding:12px 0;text-align:center}
.sel-list{display:flex;flex-direction:column;gap:6px}
.sel-item{display:flex;align-items:center;gap:10px;padding:8px;background:#fafafa;border:1px solid #eee;border-radius:6px}
.sel-num{width:26px;height:26px;border-radius:50%;background:#2d5a27;color:#fff;font-size:12px;font-weight:700;display:flex;align-items:center;justify-content:center;flex-shrink:0}
.sel-thumb{width:56px;height:56px;border-radius:4px;overflow:hidden;flex-shrink:0;background:#e0e0e0}
.sel-thumb img{width:100%;height:100%;object-fit:cover}
.sel-info{flex:1;min-width:0}
.sel-url{font-size:11px;color:#888;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.sel-label-select{padding:4px 8px;border:1px solid #ccc;border-radius:4px;font-size:12px;margin-top:4px}
.sel-actions{display:flex;flex-direction:column;gap:2px;flex-shrink:0}
.sel-actions button{width:28px;height:28px;border:1px solid #ddd;border-radius:4px;background:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;color:#555}
.sel-actions button:hover{background:#eee}
.sel-actions button.remove{color:#c33}

/* Back link */
.back-link{display:inline-flex;align-items:center;gap:4px;color:#2d5a27;font-size:13px;font-weight:500;text-decoration:none;margin-right:auto}
.back-link:hover{text-decoration:underline}

/* Mobile species selector */
.mobile-select{display:none;width:100%;padding:10px 14px;border:1px solid #ddd;border-radius:8px;font-size:14px;font-family:inherit;background:#fff;color:#222;margin-bottom:12px;-webkit-appearance:none;appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 12px center}

/* Responsive */
@media(max-width:700px){
  .sidebar{display:none}
  .mobile-select{display:block}
  .main{flex-direction:column;height:auto;min-height:calc(100vh - 45px)}
  .content{padding:12px}
  .img-grid{grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:6px}
  .toolbar{gap:6px}
  .toolbar button{padding:5px 10px;font-size:12px}
  .sel-item{flex-wrap:wrap;gap:8px}
  .sel-thumb{width:44px;height:44px}
  .sel-actions{flex-direction:row}
  .top-bar h1{font-size:14px}
}
</style>
</head>
<body>
<div class="top-bar">
  <a class="back-link" href="index.html"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" width="14" height="14" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7" stroke-linecap="round" stroke-linejoin="round"/></svg>Back</a>
  <h1>Image Curator</h1>
  <div style="display:flex;align-items:center;gap:10px">
    <div id="gh-status" style="font-size:12px"></div>
    <button onclick="showTokenPrompt()" style="background:none;border:1px solid #ccc;border-radius:4px;padding:3px 8px;cursor:pointer;font-size:18px" title="GitHub token">&#128273;</button>
    <div class="progress"><strong id="prog-count">0</strong> / 20 curated</div>
  </div>
</div>
<div class="main">
  <div class="sidebar" id="sidebar"></div>
  <div class="content" id="content">
    <select class="mobile-select" id="mobile-select" onchange="if(this.value)selectSpecies(this.value)">
      <option value="">Choose a species...</option>
    </select>
    <div class="status" id="main-status">Select a species to begin curating images.</div>
  </div>
</div>

<script>
// ================================================================
// SPECIES
// ================================================================
const SPECIES = [
  'Fagus sylvatica','Quercus robur','Betula pendula','Fraxinus excelsior',
  'Tilia cordata','Alnus glutinosa','Populus tremula','Ulmus glabra',
  'Picea abies','Pinus sylvestris','Larix decidua','Acer platanoides',
  'Acer pseudoplatanus','Aesculus hippocastanum','Carpinus betulus',
  'Sorbus aucuparia','Prunus avium','Prunus padus','Salix caprea',
  'Crataegus monogyna'
];

const LABELS = ['Whole tree','Bark','Leaves','Flowers','Fruit/Seeds','Buds/Twigs','Autumn','Other'];

const COMMONS = 'https://commons.wikimedia.org/w/api.php';

// Categories to skip (not useful for field identification)
const SKIP_CAT = new RegExp([
  // Cultivars & varieties
  'cultivar','purpurea','pendula','asplenifolia','tortuosa','fastigiata',
  'dawyck','zlatia','tricolor','laciniata','rotundifolia','atropurpurea',
  'atropunicea','riversii','dissecta','lutescens','columnaris','variegat',
  // Art & illustrations
  'illustration','drawing','painting','engrav','watercolour','artwork',
  'print','lithograph','woodcut','sculpture','carving','statue',
  // Wood products & industry
  '\\bwood\\b','timber','lumber','furniture','veneer','plank','charcoal',
  // Locations & geography (subcats like "Fagus sylvatica in France")
  'in\\s+(the\\s+)?[A-Z]','\\bin\\s+\\w+$','country','region','province',
  'national','state\\b','county','district','municipality',
  // Historical & archival
  'histor','archiv','\\bold\\b','centur','vintage','antique','heritage',
  'monument','memorial',
  // People & events
  'people','person','human','portrait','tourist','visitor','child',
  'festival','ceremony','event','exhibition',
  // Landscape & urban
  'avenue','street','park[^a-z]','garden','urban','city','town','village',
  'road','path','landscape','panorama','skyline','aerial',
  // Science & specimens
  'fossil','herbarium','microscop','anatomy','cross.?section','pollen',
  'phytopatholog','mycolog',
  // Disease & pests
  'disease','pest','gall','infest','damage','declin','dieback',
  // Forestry & management
  'forest','forestry','logging','plantation','nursery','seedling',
  'hedge','shelter.?belt','coppic','pollard',
  // Other non-useful
  'root','stump','\\bdead\\b','fallen','storm','symbol','heraldry',
  'coat.?of.?arms','emblem','\\bflag\\b','stamp','currency','banknote',
  'food','culinar','recipe','honey','syrup','medicine','pharm',
  'mythology','folklore','legend','literature','book','film','album',
  // Commons-specific junk categories
  'animal','bonsai','distribution.?map','famous','incidental',
  'low.?quality','named.?individual','notable','champion.?tree',
  'oldest','largest','record.?tree','remarkable'
].join('|'), 'i');

// Filenames to skip
const SKIP_FILE = new RegExp([
  // Wood & products
  'wood[_ ]','timber','lumber','plank','floor','veneer','board','furniture',
  'charcoal','firewood','pellet',
  // Science & specimens
  'fossil','herbarium','microscop','cross[_ -]?section','anatomy',
  'pollen[_ ]grain','histolog','cytolog',
  // Art & reproductions
  'painting','drawing','illustration','engraving','lithograph','woodcut',
  'watercolour','artwork','sculpture','statue','carving',
  // Historical & archival
  'historical[_ ]','\\d{4}[_ ](painting|drawing|engraving|print)',
  'archiv','centur','vintage','antique','postcard',
  // People
  'person','people','portrait','tourist','crowd','group[_ ]of[_ ]people',
  'child','woman','\\bman\\b','selfie','farmer','worker','student',
  // Non-photo media
  'museum','stamp','coin','logo','icon','map[_ ]','diagram','\\bflag\\b',
  '\\.svg','chart','graph','infographic','screenshot','scan[_ ]',
  // Cultivars
  'cultivar','purpurea','pendula','asplenifolia','tortuosa','fastigiata',
  'f\\.\\s?purpurea','variegat',
  // Products & food
  'food','dish','plate','bowl','jam','pie','cake','syrup','tea[_ ]',
  'honey','juice','wine','beer','liqueur','table[_ ]','kitchen',
  // Urban & landscape
  'aerial','panorama','skyline','drone','satellite'
].join('|'), 'i');

// Map subcategory keywords → label
const LABEL_MAP = [
  { label:'Leaves',      kw:/\b(leaf|leaves|leav|foliage|needle|needles)\b/i },
  { label:'Bark',        kw:/\b(bark|trunk|rind)\b/i },
  { label:'Flowers',     kw:/\b(flower|flowers|blossom|catkin|infloresc|strobil)\b/i },
  { label:'Fruit/Seeds', kw:/\b(fruit|fruits|seed|seeds|cone|cones|acorn|nut|berry|berries|haw|samara)\b/i },
  { label:'Buds/Twigs',  kw:/\b(bud|buds|twig|shoot)\b/i },
  { label:'Autumn',      kw:/\b(autumn|fall|herbst)\b/i },
];

function guessLabel(catName) {
  for (const m of LABEL_MAP) {
    if (m.kw.test(catName)) return m.label;
  }
  return 'Whole tree';
}

function shortCatName(catTitle, speciesName) {
  // "Category:Fagus sylvatica (bark)" → "bark"
  let s = catTitle.replace(/^Category:/i, '').trim();
  s = s.replace(new RegExp(speciesName.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'), 'i'), '').trim();
  s = s.replace(/^\(|\)$/g, '').replace(/^[-–—_\s]+|[-–—_\s]+$/g, '').trim();
  return s || 'general';
}

// ================================================================
// GITHUB CONFIG
// ================================================================
const GH_OWNER = 'StefanWiswedel';
const GH_REPO  = 'PlantID';
const GH_FILE  = 'images.json';
const GH_API   = 'https://api.github.com';

let ghBranch = null;   // detected from GitHub Pages config
let ghToken = localStorage.getItem('gh-token') || '';
let ghFileSha = null;  // SHA of the current images.json (needed for updates)

// ================================================================
// STATE
// ================================================================
let curatedData = {};    // { "Fagus sylvatica": [{url, label}, ...], ... }
let currentSpecies = null;
let loadedImages = [];   // [{url, thumbUrl, srcLabel, catName}]
let selectedImages = []; // [{url, thumbUrl, label}]
let isLoading = false;
let isSaving = false;

// ================================================================
// COMMONS API
// ================================================================
async function fetchSubcats(name) {
  const url = COMMONS + '?action=query&list=categorymembers' +
    '&cmtitle=Category:' + encodeURIComponent(name) +
    '&cmtype=subcat&cmlimit=50&format=json&origin=*';
  try {
    const r = await fetch(url);
    if (!r.ok) return [];
    const d = await r.json();
    if (!d.query || !d.query.categorymembers) return [];
    return d.query.categorymembers.map(c => c.title);
  } catch { return []; }
}

async function fetchCatFiles(catTitle, limit) {
  const url = COMMONS + '?action=query' +
    '&generator=categorymembers' +
    '&gcmtitle=' + encodeURIComponent(catTitle) +
    '&gcmtype=file&gcmlimit=' + limit +
    '&prop=imageinfo&iiprop=url&iiurlwidth=400' +
    '&format=json&origin=*';
  try {
    const r = await fetch(url);
    if (!r.ok) return [];
    const d = await r.json();
    if (!d.query || !d.query.pages) return [];
    return Object.values(d.query.pages)
      .filter(p => p.imageinfo && p.imageinfo[0] && p.imageinfo[0].thumburl)
      .filter(p => /\.(jpg|jpeg|png)$/i.test(p.title || ''))
      .filter(p => !SKIP_FILE.test(p.title || ''))
      .map(p => ({
        thumbUrl: p.imageinfo[0].thumburl,
        fullUrl: p.imageinfo[0].thumburl.replace('/400px-', '/800px-')
      }));
  } catch { return []; }
}

async function loadImagesForSpecies(species) {
  const name = species.replace(/ /g, '_');
  const allImages = [];
  const seen = new Set();

  // Fetch subcategories
  const subcats = await fetchSubcats(name);
  const validSubcats = subcats.filter(c => !SKIP_CAT.test(c));

  // Build fetch tasks: parent + subcats
  const tasks = [];

  // Parent category — up to 50
  tasks.push({ cat: 'Category:' + name, limit: 50, label: 'general' });

  // Each subcategory — up to 20
  for (const cat of validSubcats) {
    const sn = shortCatName(cat, species);
    tasks.push({ cat, limit: 20, label: sn });
  }

  // Fetch all in parallel
  const results = await Promise.all(
    tasks.map(t => fetchCatFiles(t.cat, t.limit).then(imgs => ({ imgs, label: t.label, cat: t.cat })))
  );

  for (const r of results) {
    for (const img of r.imgs) {
      if (!seen.has(img.thumbUrl)) {
        seen.add(img.thumbUrl);
        allImages.push({
          thumbUrl: img.thumbUrl,
          url: img.fullUrl,
          srcLabel: r.label,
          suggestedLabel: guessLabel(r.cat + ' ' + r.label)
        });
      }
    }
  }

  return allImages;
}

// ================================================================
// SIDEBAR
// ================================================================
function renderSidebar() {
  const el = document.getElementById('sidebar');
  el.innerHTML = SPECIES.map(sp => {
    const done = curatedData[sp] && curatedData[sp].length > 0;
    const active = sp === currentSpecies;
    return '<div class="sp-item' + (active ? ' active' : '') + '" onclick="selectSpecies(\'' + sp.replace(/'/g, "\\'") + '\')">' +
      '<div class="sp-tick' + (done ? ' done' : '') + '">' + (done ? '✓' : '') + '</div>' +
      '<div class="sp-info"><div class="sp-en">' + sp + '</div></div></div>';
  }).join('');
  // Mobile dropdown
  const sel = document.getElementById('mobile-select');
  if(sel) {
    sel.innerHTML = '<option value="">Choose a species...</option>' +
      SPECIES.map(sp => {
        const done = curatedData[sp] && curatedData[sp].length > 0;
        return '<option value="' + escAttr(sp) + '"' + (sp===currentSpecies?' selected':'') + '>' + (done?'✓ ':'') + sp + '</option>';
      }).join('');
  }
  updateProgress();
}

function updateProgress() {
  const count = SPECIES.filter(sp => curatedData[sp] && curatedData[sp].length > 0).length;
  document.getElementById('prog-count').textContent = count;
}

// ================================================================
// SPECIES SELECTION
// ================================================================
async function selectSpecies(species) {
  if (isLoading) return;
  // Save current selection before switching
  saveCurrentSelection();

  currentSpecies = species;
  renderSidebar();

  // Restore previous selections for this species
  selectedImages = [];
  if (curatedData[species]) {
    selectedImages = curatedData[species].map(item => ({
      url: item.url,
      thumbUrl: item.url.replace('/800px-', '/400px-'),
      label: item.label
    }));
  }

  // Show loading
  isLoading = true;
  document.getElementById('content').innerHTML =
    '<div class="toolbar">' + renderToolbarButtons() + '</div>' +
    '<div class="loading">Loading images for <strong>' + species + '</strong> from Wikimedia Commons...</div>';

  try {
    loadedImages = await loadImagesForSpecies(species);
    isLoading = false;
    renderContent();
  } catch (e) {
    isLoading = false;
    document.getElementById('content').innerHTML =
      '<div class="toolbar">' + renderToolbarButtons() + '</div>' +
      '<div class="status">Error loading images: ' + e.message + '</div>';
  }
}

function saveCurrentSelection() {
  if (!currentSpecies) return;
  if (selectedImages.length > 0) {
    curatedData[currentSpecies] = selectedImages.map(img => ({
      url: img.url,
      label: img.label
    }));
  } else {
    delete curatedData[currentSpecies];
  }
  renderSidebar();
}

// ================================================================
// RENDER
// ================================================================
function renderToolbarButtons() {
  return '<button class="primary" onclick="saveToGitHub()"' + (isSaving ? ' disabled' : '') + '>Save to repo</button>' +
    '<button class="danger" onclick="clearSelection()">Clear selection</button>';
}

function renderContent() {
  if (!currentSpecies) {
    document.getElementById('content').innerHTML = '<div class="status">Select a species from the sidebar.</div>';
    return;
  }

  const selectedUrls = new Set(selectedImages.map(s => s.thumbUrl));

  // Group by source label
  const groups = {};
  for (const img of loadedImages) {
    const key = img.srcLabel;
    if (!groups[key]) groups[key] = [];
    groups[key].push(img);
  }

  // Sort groups: "general" last, rest alphabetical
  const groupKeys = Object.keys(groups).sort((a, b) => {
    if (a === 'general') return 1;
    if (b === 'general') return -1;
    return a.localeCompare(b);
  });

  let gridHTML = '';
  for (const key of groupKeys) {
    gridHTML += '<div class="cat-section"><div class="cat-label">' + escHtml(key) +
      ' (' + groups[key].length + ')</div><div class="img-grid">';
    for (const img of groups[key]) {
      const sel = selectedUrls.has(img.thumbUrl);
      const idx = sel ? selectedImages.findIndex(s => s.thumbUrl === img.thumbUrl) + 1 : 0;
      gridHTML += '<div class="thumb' + (sel ? ' selected' : '') + '" onclick="toggleImage(this,\'' + escAttr(img.thumbUrl) + '\',\'' + escAttr(img.url) + '\',\'' + escAttr(img.suggestedLabel) + '\')">' +
        '<img src="' + escAttr(img.thumbUrl) + '" loading="lazy" onerror="this.parentNode.innerHTML=\'<div class=thumb-err>Failed</div>\'">' +
        '<div class="thumb-badge">' + idx + '</div>' +
        '<div class="thumb-src">' + escHtml(img.srcLabel) + '</div></div>';
    }
    gridHTML += '</div></div>';
  }

  const html = '<div class="toolbar">' + renderToolbarButtons() + '</div>' +
    (loadedImages.length === 0
      ? '<div class="status">No images found for ' + currentSpecies + '</div>'
      : gridHTML) +
    renderSelectedPanel();

  document.getElementById('content').innerHTML = html;
}

function renderSelectedPanel() {
  let html = '<div class="sel-panel"><h3>Selected images (' + selectedImages.length + ')</h3>';
  if (selectedImages.length === 0) {
    html += '<div class="sel-empty">Click thumbnails above to select images. Image #1 will be the hero/cover image.</div>';
  } else {
    html += '<div class="sel-list">';
    selectedImages.forEach((img, i) => {
      html += '<div class="sel-item">' +
        '<div class="sel-num">' + (i + 1) + '</div>' +
        '<div class="sel-thumb"><img src="' + escAttr(img.thumbUrl) + '"></div>' +
        '<div class="sel-info">' +
        '<select class="sel-label-select" onchange="changeLabel(' + i + ',this.value)">' +
        LABELS.map(l => '<option value="' + escAttr(l) + '"' + (img.label === l ? ' selected' : '') + '>' + escHtml(l) + '</option>').join('') +
        '</select>' +
        '<div class="sel-url">' + escHtml(img.url) + '</div></div>' +
        '<div class="sel-actions">' +
        (i > 0 ? '<button onclick="moveImage(' + i + ',-1)" title="Move up">↑</button>' : '<button disabled>↑</button>') +
        (i < selectedImages.length - 1 ? '<button onclick="moveImage(' + i + ',1)" title="Move down">↓</button>' : '<button disabled>↓</button>') +
        '<button class="remove" onclick="removeImage(' + i + ')" title="Remove">✕</button>' +
        '</div></div>';
    });
    html += '</div>';
  }
  html += '</div>';
  return html;
}

// ================================================================
// INTERACTIONS
// ================================================================
function toggleImage(el, thumbUrl, fullUrl, suggestedLabel) {
  const idx = selectedImages.findIndex(s => s.thumbUrl === thumbUrl);
  if (idx >= 0) {
    selectedImages.splice(idx, 1);
  } else {
    selectedImages.push({ thumbUrl, url: fullUrl, label: suggestedLabel });
  }
  saveCurrentSelection();
  renderContent();
}

function moveImage(idx, dir) {
  const newIdx = idx + dir;
  if (newIdx < 0 || newIdx >= selectedImages.length) return;
  const tmp = selectedImages[idx];
  selectedImages[idx] = selectedImages[newIdx];
  selectedImages[newIdx] = tmp;
  saveCurrentSelection();
  renderContent();
}

function removeImage(idx) {
  selectedImages.splice(idx, 1);
  saveCurrentSelection();
  renderContent();
}

function changeLabel(idx, val) {
  selectedImages[idx].label = val;
  saveCurrentSelection();
}

function clearSelection() {
  if (selectedImages.length === 0) return;
  if (!confirm('Clear all selected images for ' + currentSpecies + '?')) return;
  selectedImages = [];
  saveCurrentSelection();
  renderContent();
}

// ================================================================
// GITHUB API — load & save images.json directly on the repo
// ================================================================
function ghHeaders() {
  return {
    'Accept': 'application/vnd.github.v3+json',
    'Authorization': 'token ' + ghToken
  };
}

async function detectBranch() {
  // Use the GitHub Pages API to find which branch is being served
  try {
    const r = await fetch(GH_API + '/repos/' + GH_OWNER + '/' + GH_REPO + '/pages', { headers: ghHeaders() });
    if (r.ok) {
      const data = await r.json();
      if (data.source && data.source.branch) {
        ghBranch = data.source.branch;
        return;
      }
    }
  } catch {}
  // Fallback: use the repo's default branch
  try {
    const r = await fetch(GH_API + '/repos/' + GH_OWNER + '/' + GH_REPO, { headers: ghHeaders() });
    if (r.ok) {
      const data = await r.json();
      ghBranch = data.default_branch || 'main';
      return;
    }
  } catch {}
  ghBranch = 'main';
}

async function loadFromGitHub() {
  if (!ghToken) return;
  updateGHStatus('loading');
  try {
    await detectBranch();
    const url = GH_API + '/repos/' + GH_OWNER + '/' + GH_REPO + '/contents/' + GH_FILE + '?ref=' + ghBranch;
    const r = await fetch(url, { headers: ghHeaders() });
    if (r.status === 404) {
      // File doesn't exist yet — that's fine, start fresh
      ghFileSha = null;
      curatedData = {};
      updateGHStatus('connected');
      return;
    }
    if (!r.ok) throw new Error('GitHub API ' + r.status);
    const data = await r.json();
    ghFileSha = data.sha;
    const content = atob(data.content.replace(/\n/g, ''));
    const parsed = JSON.parse(content);
    if (typeof parsed === 'object' && !Array.isArray(parsed)) {
      curatedData = parsed;
    }
    updateGHStatus('connected');
  } catch (err) {
    updateGHStatus('error', err.message);
  }
}

async function saveToGitHub() {
  if (!ghToken) {
    alert('Enter a GitHub token first (click the key icon in the top bar).');
    return;
  }
  saveCurrentSelection();
  const out = {};
  for (const sp of SPECIES) {
    if (curatedData[sp] && curatedData[sp].length > 0) {
      out[sp] = curatedData[sp];
    }
  }
  if (Object.keys(out).length === 0) {
    alert('Nothing to save — no species have curated images yet.');
    return;
  }

  isSaving = true;
  updateGHStatus('saving');
  try {
    const json = JSON.stringify(out, null, 2) + '\n';
    const body = {
      message: 'Update curated images (' + Object.keys(out).length + ' species)',
      content: btoa(unescape(encodeURIComponent(json))),
      branch: ghBranch
    };
    if (ghFileSha) body.sha = ghFileSha;

    const url = GH_API + '/repos/' + GH_OWNER + '/' + GH_REPO + '/contents/' + GH_FILE;
    const r = await fetch(url, {
      method: 'PUT',
      headers: { ...ghHeaders(), 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!r.ok) {
      const err = await r.json().catch(() => ({}));
      throw new Error(err.message || ('HTTP ' + r.status));
    }
    const result = await r.json();
    ghFileSha = result.content.sha;
    updateGHStatus('saved');
    setTimeout(() => { if (!isSaving) updateGHStatus('connected'); }, 2000);
  } catch (err) {
    updateGHStatus('error', 'Save failed: ' + err.message);
    alert('Save failed: ' + err.message);
  } finally {
    isSaving = false;
  }
}

function updateGHStatus(state, detail) {
  const el = document.getElementById('gh-status');
  if (!el) return;
  const branch = ghBranch ? ' <span style="font-size:11px;color:#888">(' + escHtml(ghBranch) + ')</span>' : '';
  const labels = {
    disconnected: '<span style="color:#999">Not connected</span>',
    loading:  '<span style="color:#b58900">Loading...</span>',
    saving:   '<span style="color:#b58900">Saving...</span>',
    connected:'<span style="color:#2d5a27">Connected</span>' + branch,
    saved:    '<span style="color:#2d5a27">Saved!</span>' + branch,
    error:    '<span style="color:#c33">Error' + (detail ? ': ' + escHtml(detail) : '') + '</span>'
  };
  el.innerHTML = labels[state] || '';
}

// ================================================================
// TOKEN PROMPT
// ================================================================
function showTokenPrompt() {
  const token = prompt(
    'Enter a GitHub Personal Access Token with "repo" scope.\n' +
    'Create one at: github.com/settings/tokens\n\n' +
    'Current: ' + (ghToken ? ghToken.slice(0, 8) + '...' : '(none)')
  );
  if (token === null) return; // cancelled
  ghToken = token.trim();
  if (ghToken) {
    localStorage.setItem('gh-token', ghToken);
  } else {
    localStorage.removeItem('gh-token');
  }
  init();
}

// ================================================================
// UTIL
// ================================================================
function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}
function escAttr(s) {
  return s.replace(/&/g,'&amp;').replace(/'/g,'&#39;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// ================================================================
// INIT
// ================================================================
async function init() {
  curatedData = {};
  ghFileSha = null;
  if (ghToken) {
    await loadFromGitHub();
  } else {
    updateGHStatus('disconnected');
  }
  renderSidebar();
  if (currentSpecies) {
    // Restore selected images for current species from loaded data
    if (curatedData[currentSpecies]) {
      selectedImages = curatedData[currentSpecies].map(item => ({
        url: item.url,
        thumbUrl: item.url.replace('/800px-', '/400px-'),
        label: item.label
      }));
    } else {
      selectedImages = [];
    }
    renderContent();
  }
}
init();
</script>
</body>
</html>
